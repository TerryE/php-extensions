LPC Quick-Start Braindump

This is a quick braindump of how LPC (a Lite Progam Cache) currently works in the form of a quick-
start guide to start hacking LPC. It assumes that you are already familiar with the corresponding
guide to APC, so doesn't include the intro sections on how to get, install, build and debug it.


1.  How LPC is different to APC.

PHP installations are broadly divided into two categories: (i) application-optimised systems which
host a single application or a set of mutually trusted applications on a dedicated server or VM; and
(ii) shared hosting environments where a hosting provider provides the infrastructure and a managed
service the hosts a (large number of) number of independent account. Accelerators such as APC
effectively address the first of these. LPC is designed to address the second category.

In a shared hosting environment, UID based access control is used to enable account separation.
Individual web-requests which require PHP script execution are executed in an account-specific UID
process: either on a per-request PHP activation (using suEXEC or suPHP), or sometimes using
per-account persistent PHP threads (using FastGCI). LPC aims to generate a comparable performance
acceleration to APC for shared hosting environments which are at a fundamentally different scaling
optimization point and infrastructure template to the dedicated server / VM.

LPC's single and simple objective is to implement a safe and efficient mechanism by which individual
PHP requests can be executed by loading (compiled) code from a single file-based opcode cache thus
avoiding the need to load and to compile the potentially many script files which implement the
application. It therefore discards: 

*   All user variable/data object caching

*	Persistent shared memory, with the necessary SMA-base memory management, lock management, SMA 
    update integrity (with a one-per-request script file database used instead)  

*   The ability to save and load caches from user files

*   The bulk of the API including the APC iterator class

*   Various tuning and reporting INI parameters

*   Lazy function and class loading (which was introduced in 2009 to support mega-applications such
    as Facebook -- see http://www.serverphorums.com/read.php?7,11145. It produces marginal if any
    performance gains for applications such as Wordpress or MediaWiki which at the upper end of the
    size range that LPC targets.

These discarded functions represent roughly two-thirds of the APC source code base, so as a
side-effect the LPC code base is a lot smaller than APC. 

LPC uses a file-based opcode cache DB. I had initially intended to use the core DBA (cdb and
cdb_make) APIs, but cdb has quite poor performance for this usecase, so I implemented my own
cachedb extension for this purpose. By default, there is a one to one relationship between the
request script and the cache. (e.g. DOCUMENT_ROOT/index.php uses DOCUMENT_ROOT/.index.php.cache by
default). This means that caches are specific to the script and is under the same ownership.
However, the PER_DIR ini parameters lpc.cache_pattern and lpc.cache_replacement provide
preg_replace-like functionality to allow the maintainer to move these caches into a separate
directory or even to map multiple scripts onto the same cache file.

In scenarios where application scripts will not be pre-cached in the systems in-memory file cache 
(and this is the typical one for LPC use), I/O which references such PHP files will require physical
I/O and the avoidance of such is key to application performance. Unfortunately PHP's default 
strategy for opening included relative path names is to do a path search for each file, which incurs
a performance hit. By default LPC therefore resolves and converts all constant relative include 
filenames to absolute form on initial compile. (See further notes on this below).  


2.  More on implementation differences between LPC and APC

When I started the development of LPC, I used a standard triage strategy with the APC code base, 
sentencing it into three categories: 
*   No longer relevant to LPC (such as variable caching) that could be removed;
*   Needing rewriting, for example the cache and pool implementations;
*   Code modules where I hoped to adopt a minimum change strategy (e.g. apc_cache.c.)

However as development progressed, I realised that LPC removed or changed so much of the APC
functionality and that it had passed the point where a full re-implementation became the most
practical approach. This also had benefit that I could consistently adopt my own preference for
minimum coding subject to clarity and functionality constraints. 

The APC policy on error handling is complicated by the need to protect the integrity of the shared
memory data structures on all failure paths. This means that error handling is in general difficult
to understand as most hard errors are handled by the function returning immediately with an error
status or NULL pointer being returning up the call stack. In LPC, there are no cache integrity
issues associated application failure as it adopts an update-on-close strategy for its file-based
opcode cache. It can therefore follow a simple error strategy: errors are treated as fatal, except
in specific cases where the application logic has functional code paths and rules to handle such
failures.
 
LPC also drops the APC context layer as this contains the storage pool and the storage pool defines
the context in LPC: copying code out goes from an exec pool to a serial one, and copying code in
v.v. Also as the pool is also thread-specific in LPC, it also contains the TSRMLS id (in the ZTS
variant) so that functions which include a pool argument can still retain thread-safety, whilst
permitting the TSRMLS_DC (et al) parameters to be dropped from those functions. lpc.h defines
equivalent macros to allow calls to wider the PHP / Zend API to recover these. 

I have taken advantage of the rewrite to move to a move Zend style of programming by (where
practical) using macros to encapsulate frequent code patterns and any Zend Engine variant coding. I
have also added extra documentation into the source, so hopefully other developers will find it
easier to get to grips with. The net result of this is that at the current git version, the line
counts are 5.4K source lines for LPC against 16.1K for APC with the corresponding comments:code
percentages are 41%:59% and 34%:66%.


3.  Opcode caching at 20,000 ft

The PHP Zend engine is a compile and go system which compiles down to an intermediate form that is
build largely on the PHP storage mechanisms (zvals, hashtables, etc) and its emalloc memory
management subsystem to a format which is then interpreted by the Zend RTS. On request completion,
the RTS runs a destructor to enumerate and destroy these intermediate forms for each function,
class, etc. 

PHP processes each request by using the Zend compiler to compile one or more source files into an
internal binary format. This is then executed by the Zend execution engine. LPC hooks into this
compile subsystem intercepting the compile request. If no copy of the module exists in its cache,
then it calls the underlying PHP compiler to do its business, but then does a copy of the compiled
out to a serial format before passing control back to the execution system to run the code. 

A PHP request can be initiated in various ways, such as a php parameter in the case of a php-cli
script or as a URI scriptname as a webserver request. This resolves to the first source which is
then compiled and loaded. Each compiled source has an associated op_array which contains the
compiled version of the top-level source lines, and generates a function and class hierarchy for
each function or class in the source. Likewise each function has an associated op_array, and each
class contains a function entry for each static or object method within the class, and an op_array
which is executed on loading to initiate any static methods.  This record structure hierarchy can
be represented as follows:
    PHP request comprises:
    *   A set of source objects (either file or PHP string)
        *   An op_array of op lines
        *   An array of functions
            *   An op_array of op lines
	    *   An array of classes
            *   An op_array of op lines
            *   An array of functions.

Each of these hierarchies for source, function, class and op_array have a further internal structure 
which is documented in its relevant lpc_copy implementation (e.g. lpc_copy_class.c for classes).

Note that PHP implements conditional compilation of functions and classes, for example:
    if ($flag) {
        function mass($x) { return $x; }
    } else {
        function mass($x) { return 2.20462*$x; }
    }        
by statically compiling the two mass functions, each assigned a unique "mangled" name that is not
directly callable, and then substituting the declaration inline with a ZEND_DECLARE_FUNCTION
instruction which establishes a synonym "mass" for the relevant mangled name. This means that the
compilation process is not recursive or conditional.  Any individual source compilation is triggered
by execution of one of the compilation request statements (the request initiator, include,
include_once, require, require_once, eval, create_function).  This source is then completely 
compiled and control passed back to the execution system.

Hence the compilation unit is the source object and the Zend compiler is invoked per source and
generating a set of elements which represent an in-memory data hierarchy reflecting the above
structure.  In LPC, this compilation step is intercepted for FILE-BASED sources; e.g. a dynamic
compile of a string with eval() or create_function() is effectively bypassed by LPC. 

A "pool" interface is used to manage the allocation of this set of storage elements and their
internal references to facilitate compile caching. Pools exists in one of two formats:

-   An exec pool is a pure in-memory structure where each element is associated with a fixed
    allocated memory location and references are simply the size_t address pointers to the
    referenced elements. This is the format that is generated by the compiler and executed by the
    execution environment.

-   A serial pool is a non-executable form of the same that is written out to the Cache DB and can
    then be subsequently reloaded into a different memory allocation. Hence it must be in a position
    independent form -- that is all internal reference are now size_t offsets of the referenced
    element from the start of the pool. This pool format can be simply treated as a single binary
    block for I/O purposes.

A cacheable source compilation involves two pools, one in each format, with the LPC "copying out"
from exec to serial format during initial compile, and "copying in" from serial to exec format for
subsequent cached reloads.

    COMPILATION
	source -> [compiler] -> exec pool         ->   [execution environment]
                                |
                          [LPC copy (out)]
                                |
                                V
                           serial pool        ->   cache DB
  
    CACHED "COMPILE"
        cache DB    ->     serial pool
                                |
                          [LPC copy (in)]
                                |
                                V
	                        exec pool         ->   [execution environment]
 
Since the pool content from initial compile is written to disk prior to subsequent reload, it leaves
no residual in-memory content.  Hence all copies from one pool format to another must be deep
copies.  Also in copy-out from exec to serial pool format, the copy function must explicitly or
implicitly tag any intra-pool references so that they can be converted to and from offset form
during the copy. External-to-pool references either need to be explicitly overwritten by the copy-in
code, or they must refer to invariant addresses, e.g. function address within the PHP executable. 

When LPC receives a request to compile a source, it first checks to see if a copy of the compiled
source exists in the request cache.  The normal situation is that a copy of the compiled source
already exists in its cache, and in this case it does a deep copy from the serial format back into
exec format, in effect recreating the compiler output but without invoking the compiler, and again
passing control back to the execution system to run the code.  This is LPC in a nutshell.  

In terms of its implementation, wherever practical the LPC source code is unified into a single code
set for both copy in and copy out variants.  However, the Zend engine has made various changes to
the layout of internal data structures across its version, so where practical define macros and
conditional compilation have been used to allow a single code base to be used for all supported
variants (Zend 2.0 or later).  The main exception to this arises from the fact that the copy-out /
unload process only occurs once per version of a given PHP source configuration, but the reload /
copy-in process occurs once-per source file per request: write-once, read-many.  So whilst in 
general the emphasis is on simplicity and clarity in coding, in certain circumstances (especially
when functional differences exist between copy-in and copy-out) a second two variant exists for
copy-in, with this optimized for performance.

The structure of the code is now aligned to the hierarchy with the following modules:

    Module                  Scope / Description
    php_lpc.c               Standard PHP extension module for LPC
    lpc_request.c           Per script request processing
    lpc_copy_source.c       Per source-file (copy) processing
    lpc_copy_op_array.c     Per op_array (copy) processing
    lpc_copy_function.c     Per function (copy) processing
    lpc_copy_class.c        Per class (copy) processing
    lpc_hashtable.c         Hashtable copy utilities
    lpc_cache.c             Cache implementation wrapping the file DB access routines
    lpc_pool.c              Pool implementation
    lpc.c                   Miscellaneous utilities
    lpc_string.c            String utilities
    lpc_debug.c             Debug utilities

Each has its own header file exporting the public view of the modules, and there is one additional
header lpc_op_table.h used to drive the opcode copy process.

4.  Pools and Caches

The LPC pool and cache implementations are a complete rewrite compared to APC. This is because the
requirements driving their design are very different.

The cache itself is a fairly simple wrapper around a CacheDB cache file, with the file index loaded
into a hashtable as part of request initiation. It contains one record per compiled module in
initial creation order. As most scripts follow the same programmatic path (as far as module loading
is concerned) -- or at least one of a relatively small number of variants -- this means that in
practice the cache file is then read essentially sequentially during the execution process to load
all remaining modules.

The PHP initiator opens and validates the top level script, but other than this, the cache file is
the only file accessed to load all scripts under default INI settings. 

The pool supports the exec and serial forms as described above. The implementation of allocators,
etc., is private to and encapsulated within the pool module, so the upper levels of the LPC code
cannot use 'back-door' access to these and MUST call the pool functions. 

Note that the pools offer no explicit element destructors or reallocators. Serial pools are
ephemeral in that this pool type is created, used and destroyed during the life of the compilation
or reload of a source. The serial pool DTOR implicitly acts as the DTOR for all pool elements. The
exec pool type is a container for a set of emalloced objects that are passed to the PHP execution
system, so disposal / freeing of these resources is outside scope of LPC and is handled by the PHP
execution system.  Also note that the pool API includes allocator variants pool_alloc_zval() and
pool_alloc_ht exist() and these use the Zend fast allocator macros for zval and HashTable structures
for exec pools. 

The serial pool is unique to LPC, and is used to encapsulate and morph the deep copy of the record
hierarchy associated with each compilation source. There are a number of drivers of the serial pool
design:

    4.1 Serial pool storage sizing and persistence 

    The compilation process in PHP is serial, and therefore only one serial pool can be in existence
    in any PHP thread. In an application which contains 100s of source files, the repeated dynamic
    allocation and freeing such large pools can lead to dynamic storage fragmentation. Therefore by
    default LPC uses a persistent serial pool storage which is created during request startup and
    sized to contain the largest module in the file cache. It bypasses the PHP allocator and
    directly mallocs this storage, and then frees it during request shutdown.

    Rather than complicate the pool storage design (by say moving to a brick allocation scheme), a
    single contiguous memory area is used for serial pool storage, and an optimistic strategy is
    used for compiling new (and potentially larger) sources: the copy-out process assumes that the
    pool will be large enough, but detects pool memory overflow and bails out with a pool overflow
    error. The copy_source function then reallocates a larger pool storage and restarts the copy.

    This strategy avoids most of the additional alloc / free overheads of module caching and the
    coding overheads and complexities of a non-contiguous brick-based allocation scheme, at the
    run-time cost of a few aborted copy-outs during initial compilation. 

    4.2 Removing redundant content from serial pool records

    The PHP compiler output data structures are denormalised to optimized per executed instruction
    performance. They therefore contain a lot of logically redundant content. The performance
    improvements introduced in the Zend 2.4 (see https://wiki.php.net/rfc/performanceimprovements)
    were largely as a result of a review of these and backing out some denormalization that in fact
    added to overall runtime. However these clearly don't applied to Zend 2.3 and earlier. LPC
    removes some redundant content on copy-out and regenerates this on copy-in. This is a relatively
    cheap operation which reduces the size of compressed cache file records, and has a net-benefit
    on copy-in.  This content includes:
        *   Interning of strings (see 4.3)
        *   The zend_op->handler fields
        *   Unused link fields in HashTables (see 6)

    4.3 String Interning and C vs PHP strings

    (Note and health warning).  Cstrings adopt the convention of zero-byte termination of a (non-
    zero) byte string.  PHP somewhat idiosyncratically allows embedded zero-bytes in its strings but
    still retains the zero-byte termination convention. The Zend zval includes an explicit string 
    length field which excludes the terminating zero-byte, even though this is allocated and 
    assigned.  The runtime system also uses embedded zero string (e.g. for magic class and function
    names).  On the other hand, string lengths in HashTable keys include the zero-byte termination. 

    The Zend 2.4 engine introduced string interning for all strings embedded as compile-time
    constants and literals. However, LPC uses string interning for ALL Zend 2.x engine variants for
    all string constants and literals copied to serial pool storage. Whilst the Zend scheme is based
    on the address of the string in the interned pool, LPC generates a unique PIC address (high byte
    0xBB) plus the string number within the intern list. (This will typically only have 2 or 3
    non-zero bytes.) Any string copied to the serial pool is assigned an LPC interned address, and
    associated zval lengths are set to 0. Any string copied from a serial pool is de-interned (in
    Zend 2.4 reinterned in the Zend scheme).

    Compare routines allow meaningful comparison of normal, LPC and Zend interned strings. In order
    to simplify copy coding, these work on both copy-in and copy-out.

    The interned string table is appended to the serial pool on copy-out in the form of a repeat 
    of <4 byte length> <string bytes>.


    4.4 Position independence

    The deep copy process tags any putative internal pointers (that is referring to other addresses
    with the pool) in a hash table of relocation tags. This is converted into a relocation vector
    (typically one byte per pointer) which is appended to the serial pool as part of the pool
    unload. The storage base address is then subtracted from any tagged pointers at unload
    converting them to convert them to a position independent pool offset form. On subsequent reload
    of the cached source, the relocation vector is again used to add the (potentially different)
    storage base address to each pointer offset generating the correct absolute memory address for
    copy-in.

    As all string references are already in PIC interned format, these aren't tagged or relocated.

    4.5 Record compression

    The PHP compiled forms are very sparse (especially in 64bit builds) especially after copy-out
    has substitutes zero-fill for redundant fields. Compression therefore typically yields a 4-8x
    reduction in the DB filesize. This can in turn generate performance gains at reload, either in
    the memory footprint in the case of the file system VFAT-cached records and inodes, or in I/O
    latencies reading in data that is not in the VFAT cache.  The compression cost is relatively
    high, but this is only done once during initial compilation.  The expansion overhead on reload 
    is relatively cheap compared to the compilation load. 

    Three compression algorithms are selectable through the PER_DIR lpc.compression INI setting read
    prior to cache file creation. (The compression algorithm is then fixed for a created cache
    file.) These are (=0) no compression; (=1) zero RLE encoding; (=2) standard zlib compression.
    Option 1 is the default as this gives comparable record sizes to option 2 for PHP compiler
    output but has minimal CPU overhead for loading.

To simplify coded use of the pool API:

*   All pool allocation routines take a (void**) destination as an input parameter and return the
    (void*) to the destination address. This means that pointer tagging can be encapsulated by
    default within the allocator layer. (Also each API allocator function is also wrapped in a macro
    to allow the first argument to be expressed in any valid lvalue format). This enables most
    internal pointer tagging required for serial pool form to be handled internally within the pool
    logic. However there also is an explicit tag function to enable upper copy code to use the 
    pattern: 

	    pool_alloc(tmp, some_size);
	    ...
	    dest = tmp;
	    pool_tag_ptr(dest);

    These allocation macros also use source line forwarding to the underlying PHP _emalloc
    allocators, so that the memory leakage reports in debugging mode give meaningful source
    addresses rather than all pointing to some line in the pool allocator routine.

*   All any allocation failures / memory exhaustion throw errors rather than return a NULL value.
    This simplifies error coding as the upper call levels do not need to check for or handle
    potential zero pointer returns. In the case of the emalloc layered call, memory exhaustion is
    already handled this way by the PHP runtime environment. In the case of pool memory exhaustion,
    this is caught programmatically by copy source function as discussed above. 


6.  Record Formats and Hash Tables

APC copies the standard PHP structures for classes, etc., into serial pools. However, as such
serialised structures are never directly referenced by the Zend runtime access routines, many fields
are redundant in the serialised format (for example the pListLast linked chain in hash tables).
Zeroing such redundant fields on copy out leads to a material size reduction in the cached record
sizes, because the serial pools compressed for output to the cache. Hence the deep copy of an
element in the compiler data hierarchy involves:

*   Pool allocating the destination storage element

*   Doing a bit-copy image from the source record to the destination one

*   Explicitly zeroing any fields that aren't in scope in the destination form

*   Processing any child data elements where bit-copy isn't valid. These are most typically
    references to child structures which have associated copy functions that need to be called.
 
The redundant fields are recalculated on copy-in.  

Many structures are collections of child elements; for example a class has an array of function
records one for each method, and PHP uses unified HashTable implementation for all PHP arrays and
dictionaries including these. So LPC has a standard HashTable copy utility with callback hooks to
permit element selection and to implement the element copy.  As just discussed, the serial form of 
HashTable storage used a reduced format, so with the hash table buckets for example:

typedef struct bucket {
        ulong h;                                 /* Element id or hash */
        uint nKeyLength;                         /* Moved to before arKey to optimize alignment */
        void *pData;                             /* Used */
        void *pDataPtr;                          /* Zeroed */
        struct bucket *pListNext;                /* Used */
        struct bucket *pListLast;                /* Zeroed */ 
        struct bucket *pNext;                    /* Zeroed */
        struct bucket *pLast;                    /* Zeroed */
        char arKey[1];                           /* Actually [nKeyLength] so must be last element */
} Bucket;

The pListNext field is sufficient to enumerate the serial HashTable, and the HashTable copy-in
function regenerates all of these pointers whilst building the exec format HashTable. Doing this
typically halves the number of pointers that need to tagged and relocated during copy-in and
copy-out.  

Using the same record structure for both exec and serial formats simplifies the copy and fixup
callback routines which take the bucket as a parameter. Output compression means that this does have
a material runtime cost.


7.  Miscellaneous Issues

Conversion of constant relative include filenames to absolute form on initial compile can fail for
certain code patterns, for example:

    $app_root = dirname(__FILE__);
    set_include_path("$app_root/includes_dir:$app_root/another_dir:$app_root');
    ...
    include ('some_module.php');

will fail because the include path is set during execution and will therefore not be set at compile
time.  However

    include ("$app_root/more_includes.php");
     
will work as expected since (i) more_includes.php is included via a variable (containing an absolute
path) and (ii) the include path will be correct for any files included within more_includes.php. The
PER_DIR INI flag lpc.resolve_path can be set to 0 to disable this resolution function in cases where
the application maintainer has this problem and can't resolve it by code modification.
