LPC Quick-Start Braindump

This is a quick braindump of how LPC (a Lite Progam Cache) currently works in the form of a quick-
start guide to start hacking LPC. It assumes that you are already familiar with the corresponding
guide to APC, so doesn't include the intro sections on how to get, install, build and debug it.


1.  How LPC is different to APC.

PHP installations are broadly divided into two categories: (i) application-optimised systems which
host a single application or a set of mutually trusted applications on a dedicated server or VM; and
(ii) shared hosting environments where a hosting provider provides the infrastructure and a managed
service the hosts a (large number of) number of independent account. Accelerators such as APC
effectively address the first of these. LPC is designed to address the second category.

In a shared hosting environment, UID based access control is used to enable account separation.
Individual web-requests which require PHP script execution are executed in an account-specific UID
process: either on a per-request PHP activation (using suEXEC or suPHP), or sometimes using
per-account persistent PHP threads (using FastGCI). LPC aims to generate a comparable performance
acceleration to APC for shared hosting environments which are at a fundamentally different scaling
optimization point and infrastructure template to the dedicated server / VM.

LPC's single and simple objective is to implement a safe and efficient mechanism by which individual
PHP requests can be executed by loading (compiled) code from a single file-based opcode cache thus
avoiding the need to load and to compile the potentially many script files which implement the
application. It therefore discards: 

*   All user variable/data object caching

*	Persistent shared memory, with the necessary SMA-base memory management, lock management, SMA 
    update integrity (with a one-per-request script file database used instead)  

*   The ability to save and load caches from user files

*   The bulk of the API including the APC iterator class

*   Various tuning and reporting INI parameters

*   Lazy function and class loading (which was introduced in 2009 to support mega-applications such
    as facebook -- see http://www.serverphorums.com/read.php?7,11145. It produces marginal if any
    performance gains for applications such as Wordpress or MediaWiki which at the upper end of the
    size range that LPC targetted at.

These discarded functions represent roughly two-thirds of the APC source code base, so as a
side-effect the LPC code base is a lot smaller than APC. 


2.  More on LPC differences from APC

When I started the development of LPC, I used a standard triage strategy with the APC code base, 
sentencing it into three categories: 

*   Stuff which is no longer relevant to LPC (such as variable caching) and that could be removed;

*   Stuff which needed rewriting, for example the cache and pool implementations;

*   Code modules where I hoped to adopt a minimum change strategy (e.g. apc_main.c and
    apc_cache.c. 

However as I started to develop / debug these core modules I found that LPC removed so much
functionality and change much of the remainder, and that it would really be easier to do a complete
re-implementation for these modules as well. So I abandoned the minimum change policy; instead
adopting my own preference for minimum coding subject to clarity and functionality constraints. I
discuss examples in the remainder of this section. 

The APC policy on error handling is difficult to understand as in general hard errors result in
functions aborting with an error status or NULL pointer being returning up the call stack, and these
are then sometimes ignored at the higher call levels, when not ignored there was extra functionality
to protect the integrity of the SMA-base data structures. However, as LPC adopts an update-on-close
strategy for its file-based opcode cache, there are no cache integrity issues associated application
failure and it can therefore follow a simple strategy: lpc errors are treated as fatal, unless the
upper tiers of application logic have functional code paths and rules to handle such failure
returns.
 
The APC concept of a context is also dropped as the destination pool defines the context in LPC:
copying code out goes from an exec pool to a serial one, and copying code in v.v. Also as the
pool is also thread-specific, it also contains the TSRMLS id (in the ZTS variant) so that functions
which include a pool argument can still retain thread-safety, whilst allowing the TSRMLS_DC (et al)
parameters to be dropped from those functions. lpc.h defines equivalent macros to allow calls to
wider the PHP / Zend API to recover these. 

I have taken advantage of the rewrite to move to a move Zend style of programming by (where
practical) using macros to encapsulate frequent code patterns and any Zend Engine variant coding. I
have also added extra documentation into the source, so hopefully other developers will find it
easier to get to grips with. The net result of this is that at the current git version, the line
counts are 5.4K source lines for LPC against 16.1K for APC with the corresponding comments:code
percentages are 41%:59% and 34%:66%.


3.  Opcode caching at 20,000 ft

The PHP Zend engine is a compile and go system which compiles down to an intermediate form that is
build largely on the PHP storage mechanisms (zvals, hashtables, etc) and its emalloc memory
management subsystem to a format which is then interpreted by the Zend RTS. On request completion,
the RTS runs a distructor to enumerate and destroy these intermediate forms for each function,
class, etc. 

PHP processes each request by using the Zend compiler to compile one or more source files into an
internal binary format. This is in turn executed by the Zend execution engine. LPC hooks into this
compile subsystem intercepting the compile request. If no copy of the module exists in its cache,
then it calls the underlying PHP compiler to do its business, but then does a copy of the compiled
out to a serial format before passing control back to the execution system to run the code. 

The PHP compiler generates a number of record structures as follows for each PHP request:
    *   A set of source objects (either file or PHP string)
        *   An op_array of op lines
        *   An array of functions
            *   An op_array of op lines
	    *   An array of classes
            *   An op_array of op lines
            *   An array of functions.

The request can be initiated in various ways, such as a php parameter in the case of a php-cli
script or as a URI scriptname as a webserver request. This resolves to the first source loaded and
which can then include or request other sources. Each compiled source has an associated op_array
which contains the compiled version of the top-level source lines, and a function and class
hierarchy for each function or class in the source. Likewise each function contains an op_array.
Each class contains a function entry for each static or object method within the class, and op_array
which is executed on loading to initiate any static methods.

Each of these hierarchies for source, function, class and op_array have a further internal structure 
which is documented in its relevant lpc_copy implementation (e.g. lpc_copy_class.c for classes).

The compilation unit is the source object and the Zend compiler is invoked per source and generating
a set of elements which represent an in-memory data hierarchy reflecting the above structure. In
LPC, a "pool" interface is used to manage the allocation of this set of storage elements and their
internal references to facilitate compile caching. Pools exists in one of two formats:

-   An exec pool is a pure in-memory structure where each element is associated with a fixed
    allocated memory location and references are simply the size_t address pointers to the
    referenced elements. This is the format that is generated by the compiler and executed by the
    execution environment.

-   A serial pool is a non-executable form of the same that is written out to the Cache DB and can
    then be subsequently reloaded into a different memory allocation. Hence it must be in a position
    independent form -- that is all internal reference are now size_t offsets of the referenced
    element from the start of the pool. This pool format can be simply treated as a single binary
    block for I/O purposes.

A non-cacheable source -- e.g. a dynamic compile of a string with eval() or create_function() --
only has the executable form and is effectively bypassed by LPC. A cacheable source compilation
involves two pools, one in each format, with the LPC "copying out" from exec to serial format during
initial compile, and "copying in" from serial to exec format for subsequent cached reloads.

    COMPILATION
	source -> [compiler] -> exec pool         ->   [execution environment]
                                |
                          [LPC copy (out)]
                                |
                                V
                           serial pool        ->   cache DB
  
    CACHED "COMPILE"
        cache DB    ->     serial pool
                                |
                          [LPC copy (in)]
                                |
                                V
	                        exec pool         ->   [execution environment]
 
Since the pool content from initial compile is written to disk prior to subsequent reload it has no
residual in-memory content, and so all copies from one pool format to another must be deep copies.
Also in copy-out from exec to serial pool format, the copy function must explicitly or implicitly
tag any intra-pool references so that they can be converted to and from offset form during the copy.
External-to-pool references either need to be explicitly overwritten by the copy-in code, or they
must refer to invariant addresses, e.g. function address within the PHP executable. 

When LPC receives a request to compile a source, it first checks to see if a copy of the compiled
source exists in the request cache. However the normal situation is that a copy of the compiled
source already exists in its cache, and in this case it does a deep copy from the serial format back
into exec format, in effect recreating the compiler output but without invoking the compiler, and
again passing control back to the execution system to run the code. This is LPC in a nutshell.  

In terms of its implementation, the LPC source code is unified into a single code set for both copy
in and copy out variants wherever practical. However, the Zend engine has made various changes to
the layout of internal data structures across its version, so where necessary conditional
compilation and macros have been used to allow a single code base to be used for all supported
variants (Zend 2.0 or later). There is one exception to this and that arises from the observation
that the copy-out / unload process only occurs once per version of a given PHP source configuration,
but the reload / copy-in process occurs once-per source file per request: write-once, read-many. So
whilst in general the emphasis is on simplicity and clarity in coding, in certain circumstances
especially when functional differences exist between copy-in and copy-out, a second two variant
exists for copy-in, with this optimized for performance.

The structure of the code is now aligned to the hierarchy with the following modules:

    Module                  Scope / Description
    php_lpc.c               Standard PHP extension module for LPC
    lpc_request.c           Per script request processing
    lpc_copy_source.c       Per source-file (copy) processing
    lpc_copy_op_array.c     Per op_array (copy) processing
    lpc_copy_function.c     Per function (copy) processing
    lpc_copy_class.c        Per class (copy) processing
    lpc_hashtable.c         Hashtable copy utilities
    lpc_cache.c             Cache implementation wrapping the file DB access routines
    lpc_pool.c              Pool implementation
    lpc.c                   Miscellaneous utilities
    lpc_string.c            String utilities
    lpc_debug.c             Debug utilities

Each has its own header file exporting the public view of the modules, and there is one additional
header lpc_op_table.h used to drive the opcode copy process.

4.  Pools and Caches

The LPC pool and cache implementations are a complete rewrite compared to APC. This is because the
requirements driving their design are very different.

The cache is a fairly simple wrapper around a CacheDB cache file, with the file index loaded into a
hashtable as part of request initiation and contains one record per compiled module in initial
creation order. As most scripts follow the same programmatic path (as far as module loading is
concerned) -- or at least one of a relatively small number of variants -- in practice the cache file
is then read essentially sequentially during the execution process to load all remaining modules.
This is the only file accessed to load all scripts under default INI settings. 

The pool supports the exec and serial forms as described above.  Unlike APC, the implementation of
the allocators, etc., is entirely private to the pool module, so the upper levels cannot use
'backdoor' access to these and MUST call the pool functions.  Also as with the emalloc system upon
which it is based, any allocation failures / memory exhaustion throw fatal errors, so the upper
levels do not need to check for or handle potential zero pointer returns, which simplifies error 
coding. 

Special alloc variants pool_alloc_zval and pool_alloc_ht exist which use the fast allocator macros 
for zval and HashTable structures in the exec pool variants.

A serial pool is initially allocated during copy-out using a set of bricks (often only one). The
deep copy process tags any putative internal pointers during copy-out. The hash table of relocation
tags is converted into a relocation vector (typically one byte per pointer) which is appended to the
serial pool, before the bricks are logically concatenated and compressed as part of the unload
process, before being written to the DB. On reload, the size of the serial pool is known so a single
brick is used. The relocation vector is used on reload to convert all internal references from
position independent offset form to absolute pointer addresses.

Note that the pools offer no explicit element destructors or reallocators. Serial pools are
ephemeral in that this pool type is created, used and destroyed during the life of the compilation
or reload of a source. The serial pool DTOR implicitly acts as the DTOR for all pool elements. The
exec pool type is a container for a set of emalloced objects that are passed to the PHP execution
engine, and this engine carries out the DTOR of these elements. 

The reason for compression is that PHP compiled forms are very sparse, especially in 64bit builds,
and therefore compression yields a 4-8x reduction in the DB filesize which yields performance gains
at reload, either in the memory footprint in the case of the file system VFAT-cached records and
inodes, or in I/O latencies reading in data that is not in the VFAT cache. Yes, the compression cost
is relatively high, but this is only done once during initial compilation. The expansion overhead on
reload is relatively cheap compared to the compilation load. Note that standard zlib compression is
used in the initial implementation, but I am evaluating replacing this by a simple zero run encoding
scheme, as this encoding scheme will yield most of the compression benefits, but with a trivial
expansion cost at reload.  

To simplify pointer tagging, all pool allocation routines take a (void**) destination as an input
parameter and return the (void*) to the destination address. (Each is also wrapped in a macro to
allow the first argument to be expressed in any valid lvalue format). This enables most internal
pointer tagging required for serial pool form to be handled internally within the pool logic.
However there also is an explicit tag function to enable upper copy code to use the pattern: 

	pool_alloc(tmp, some_size);
	...
	dest = tmp;
	pool_tag_ptr(dest);

These allocation macros also use source line forwarding to the underlying PHP _emalloc allocators,
so that the memory leakage reports in debugging mode give meaningful source addresses rather than
all pointing to some line in the pool allocator routine.

6.  Record Formats and Hash Tables

Because the serial pool is compressed for writing to disk, there no material disadvantage to the
simple policy of using the standard PHP structures for classes, etc., in serial pool forms even if
individual fields aren't used. Hence the deep copy of an element in the compiler data hierarchy
involves:

*   Pool allocating the destination storage element

*   Doing a bit-copy image from the source record to the destination one

*   Explicitly zeroing any fields that aren't in scope in the destination form (as this improves
    compression)

*   Process any child data elements where bit-copy isn't valid. These are most typically references
    to child structures which have associated copy functions that need to be called.
 
Many fields are collections of child elements, for example a class has an array of function records
one for each method. PHP uses unified HashTable implementation for all PHP arrays and dictionaries
including these. So LPC has a standard HashTable copy utility with callback hooks to permit element
selection and to implement the element copy. The one exception to the "standard structure" policy
relates to HashTable storage in serial pool formats. This type of HashTable is never used "in anger"
so a reduced bucket format is used:

typedef struct bucket {
        ulong h;                                 /* Element id or hash */
        uint nKeyLength;                         /* Moved to before arKey to optimize alignment */
        void *pData;                             /* Used */
        void *pDataPtr;                          /* Zeroed */
        struct bucket *pListNext;                /* Used */
        struct bucket *pListLast;                /* Zeroed */ 
        struct bucket *pNext;                    /* Zeroed */
        struct bucket *pLast;                    /* Zeroed */
        char arKey[1];                           /* Actually [nKeyLength] so must be last element */
} Bucket;

The reason for this is that the pListNext field is sufficient to enumerate the serial HashTable, and
the HashTable copy-in function regenerates all of these pointers whilst building the exec format
HashTable. Doing this typically halves the number of pointers that need to tagged and relocated
during copy-in and copy-out.  

Using the same record structure for both exec and serial formats simplifies the copy and fixup
callback routines which take the bucket as a parameter. Output compression means that this does have
a material runtime cost.

